---
title: "Collaborative Filtering Recommendation Systems Tutorial" 
authors: "Hyun Ko, Eric Tria, Chunru Zheng"
date: "Due: Wed Dec 14 | 12:00pm"
output: R6030::homework
---

**DS 6030 | Fall 2022 | University of Virginia**

------------------------------------------------------------------------

```{r config, echo=FALSE}
source(system.file("config/hw_config.R", package="R6030")) # knitr settings
options(dplyr.summarise.inform = FALSE)  # ignore dplyr message about grouping
```


# Intro

Let's suppose it's 2010 and you've just finished watching a collection of 4 movies on your handy DVD player. You still have some free time left and you decide that you want to spend the remainder of your time watching more movies. You have 3 other DVDs lying around, but you do not know which one will be good to watch - a travesty! In order to resolve this, you call up some of your closest friends and ask them to rate the DVD options that you have. While you're at it, you ask your friends to also rate the movies you already watched. 

Let's say there are 4 movies that you already watched: 
- WM1, WM2, WM3, WM4

And let's say the 3 new movies you're deciding between are:
- NM1, NM2, NM3

You were able to get a response from 3 of your friends: Hyun, Eric, and Chunru. They weren't able to provide ratings for all 7 movies, but you were still able to summarize their responses in a simple table:

|        | WM1 | WM2 | WM3 | WM4 | NM1 | NM2 | NM3 |
|--------|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| Hyun   | 5   |     | 3   | 2   | 1   | 4   | 3   |
| Eric   |     | 4   |     | 5   |     | 2   | 5   |
| Chunru | 3   | 1   |     | 4   | 5   |     | 3   |

In order to compare, you added your ratings to the table as well. The final table will look like this:

|        | WM1 | WM2 | WM3 | WM4 | NM1 | NM2 | NM3 |
|--------|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| Hyun   | 5   |     | 3   | 2   | 1   | 4   | 3   |
| Eric   |     | 4   |     | 5   |     | 2   | 5   |
| Chunru | 3   | 1   |     | 4   | 5   |     | 3   |
| You    | 4   | 2   | 3   | 5   |     |     |     |

Given this information, will you be able to decide on which movie to watch next? The answer is yes! Thankfully, it's 2022 and this concept has been around for a while now. Even more so, this concept is applied in technology through applications that predict which options a user will choose. These applications are called **Recommendation Systems**.

This tutorial will go through the concept of Recommendation Systems, specifically the technique of **Collaborative Filtering**. The following will be discussed:

1. Background of Concepts
2. Mathematical Theory
3. Coding Example (R)
4. Coding Example (Python)

# Background of Concepts

Before jumping into the math, it is important to go through some examples of recommendation systems as well as the concepts of the *Utility Matrix* and the *Long Tail*.

## Recommendation Systems

We mentioned earlier that recommendation systems are being applied in different technologies nowadays (Ullman). Some of these are:

1. Movie Recommendations - Like the initial example, recommending movies is one of the most popular examples for recommendation systems. Streaming services such as Netflix, Hulu, Disney, and others all provide recommendations for their users to try. 
2. Product Recommendations - Online shopping is another one of the avenues where recommendation systems are very useful. Users receive suggestions on products to buy based on what similar users are buying.
3. News Articles - Another example of recommendation systems are with news articles where readers will receive suggestions on articles that they may find interesting.

There are definitely are more examples but these should be able to provide an idea of the vastness of use cases where recommendation systems can be applied. Alternatively, recommendation systems

## The Utility Matrix

Recall the table we created earlier for the initial example where the different friends had their ratings for different movies. That table is a good representation of the utility matrix:

|        | WM1 | WM2 | WM3 | WM4 | NM1 | NM2 | NM3 |
|--------|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| Hyun   | 5   |     | 3   | 2   | 1   | 4   | 3   |
| Eric   |     | 4   |     | 5   |     | 2   | 5   |
| Chunru | 3   | 1   |     | 4   | 5   |     | 3   |
| You    | 4   | 2   | 3   | 5   |     |     |     |

Typically, recommendation systems have two types of entities: *users* and *entities*. The utility matrix represents the degree of preference that a user has for certain items. In our example, the degree of preference is measured on a movie rating scale of 1 to 5. It is also important to note that it is assumed that the utility matrix is sparse, meaning there are blank values in the matrix. This is good to replicate the real-world scenario where not all users would have a degree of preference for all of the items.

The goal of recommendation systems is to fill out the utility matrix by predicting values for the blank ones. Alternatively, recommendation systems can also predict the values for some entries in each row which are expected to have higher values. This would make it so that the recommendation system does not have to fill out all of the empty cells but just a large subset of cells (Ullman).

## The Long Tail

After learning a little bit about the concept of recommendation systems, it is also important to understand why these systems are necessary in technology nowadays. To picture this, we can look at a physical example. Keeping within the movie example, let's say we have a store that sells physical copies of movies. These stores tend to only sell the more popular movies. Online stores, on the other hand, would have more movies at their disposal. Recommendation systems help to recommend these less popular movies to users so that they can also be sold.

This is the long tail phenomenon, where physical stores only sell the more popular products. Recommendation systems help to present a wider range of options (Ullman).

![alt text](Long_Tail.png "The Long Tail")

## Collaborative Filtering

Recommendation systems can be implemented using different techniques, but for this tutorial we will be focusing on collaborative filtering. This technique focuses more on the similarity of users with each other instead of similarity of features between items. This follows the intuition that similar users will tend to prefer similar items and thus the recommendations are based off of this idea (Ullman). You can also think of this in terms of having *neighbors*, where neighbors are based on similar item preferences. A user will receive recommendations that are influenced by what their neighbors prefer (Gormley).

Before implementing collaborative filtering recommendation systems, we will first discuss the mathematical theory that works in the background. Specifically, we will discuss how collaborative filtering can be done through *cosine similarity* or *matrix decomposition*

# Mathematical Theory

## Cosine Distance

To measure the similarity of users from the utility matrix, we can use the Cosine Distance method, which calculates the angle between the ratings of different users. In this method, we treat the blank entries as zero. One thing to note about this method is that it latently treats the lack of a rating as disliking the movie (i.e. rating = 0) (Ullman).

[ADD GENERALIZED FORMULA?]

Using our example, we can check the similarity of some of your friends. To get the cosine angle between Hyun and Eric, we can use this equation:

$\frac{(2\times5) + (4\times2) + (3\times5)}{\sqrt{5^2+3^2+2^2+1^2+4^2+3^2}\sqrt{4^2+5^2+2^2+5^2}} = 0.493$

We can also check for the cosine angle between Hyun and Chunru:

$\frac{(5\times3) + (2\times4) + (1\times5) + (3\times3)}{\sqrt{5^2+3^2+2^2+1^2+4^2+3^2}\sqrt{3^2+1^2+4^2+5^2+3^2}} = 0.597$

Since a larger cosine value implies a smaller angle and therefore a smaller distance, this measure tells us that Hyun is closer to Chunru than to Eric.

In addition, we can normalize ratings by subtracting the average rating of each user. In this case, the movies with low ratings would become negative and those with high ratings would be positive. Users with contrasting ratings on movies would have consine vectors in opposite direction, while users with similar ratings would have smaller distances between them (Ullman).

In our example, the utility matrix after normalizing would be:

|        | WM1 | WM2 | WM3 | WM4 | NM1 | NM2 | NM3 |
|--------|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| Hyun   | 2   |     | 0   | -1  | -2  | 1   | 0   |
| Eric   |     | 0   |     | 1   |     | -2  | 1   |
| Chunru | -0.2| -2.2|     | 0.8 | 1.8 |     | -0.2|
| You    | 0.5 | -1.5| -0.5| 1.5 |     |     |     |

Then the cosine of the angle between Hyun and Eric is:

$\frac{(-1\times1) + (1\times-2)}{\sqrt{2^2+(-1^2)+(-2^2)+1^2}\sqrt{1^2+(-2^2)+1^2}} = -0.387$

The cosine of the angle between Hyun and Chunru is:

$\frac{(2\times-0.2) + (-1\times0.8) + (-2\times1.8)}{\sqrt{2^2+(-1^2)+(-2^2)+1^2}\sqrt{(-0.2^2)+(-2.2^2)+0.8^2+1.8^2+(-0.2^2)}} = -0.512$

Still we can see that Hyun is closer to Chunru than to Eric.

## UV (Matrix) Decomposition (Need to Paraphrase)

[PARAPHRASE]
An approach to estimating the blank entries in the utility matrix is to conjecture that the utility matrix is actually the product of two long, thin matrices. 

For example, if we start with the utility matrix M, with n rows and m columns (i.e., here are 4 users and 7 movies, so martix M is $4 \times 7$), then we might be able to find a $n \times d$ matrix U and a $d \times m$ matrix V, such that the product matrxi UV closely approximates M in those entries where M is **nonblank**. After that, we can then use the entries in the product UV to estimate the corresponding **blank** entries in utility matrix M. This process is called UV-decomposition of M.
[PARAPHRASE]

In our example, we decompose the utility matrix M ($4 \times 7$), into two matrix U ($4 \times 2$) and V ($2 \times 7$)

$$
\begin{bmatrix}
 5   &  &  3   &  2   & 1   &  4   &  3  \\
     &  4  &   &  5   & &  2   &  5  \\
 3   & 1   &   &  4   & 5  &   &  3   \\
 4   & 2   & 3   & 5   & & &    
\end{bmatrix}
 = 
\begin{bmatrix}
u_{11} & u_{12} \\
u_{21} & u_{22} \\
u_{31} & u_{32} \\
u_{41} & u_{42} 
\end{bmatrix}
\times 
\begin{bmatrix}
v_{11} & v_{12} & v_{13} & v_{14} & v_{15} & v_{16} & v_{17} \\
v_{21} & v_{22} & v_{23} & v_{24} & v_{25} & v_{26} & v_{27} 
\end{bmatrix}
$$
Theoratically, we can find many candidates of matrix U and V, whose product UV is close to V. So we need a measurement to pick the one that is closest to M. The typical choice is called the **root-mean-square error (RMSE)**, where we sum over the square root of the difference of nonblank entries from the martix M and the corresponding entries from product matrix UV. 

To find the UV-decomposition matrix with the least RMSE, we start with an arbitrary guess of matrix U and V, and the repeatedly adjusting one entry in U or V to make the RMSE smaller. Here we use our example to show the process of UV-decomposition.

**Step 1 : Start with matrices U and V with all entries 1:**

$$
\begin{bmatrix}
1 & 1 \\
1 & 1 \\
1 & 1 \\
1 & 1  
\end{bmatrix}
\times 
\begin{bmatrix}
1 & 1 & 1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 & 1 & 1 
\end{bmatrix}
=
\begin{bmatrix}
2 & 2 & 2 & 2 & 2 & 2 & 2 \\
2 & 2 & 2 & 2 & 2 & 2 & 2 \\ 
2 & 2 & 2 & 2 & 2 & 2 & 2 \\
2 & 2 & 2 & 2 & 2 & 2 & 2 \\
\end{bmatrix}
$$

**Step 2 : Alter u11 to reduce the RMSE as much as possible:**

$$
\begin{bmatrix}
x & 1 \\
1 & 1 \\
1 & 1 \\
1 & 1  
\end{bmatrix}
\times 
\begin{bmatrix}
1 & 1 & 1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 & 1 & 1 
\end{bmatrix}
=
\begin{bmatrix}
x+1 & x+1  & x+1  & x+1  & x+1  & x+1  & x+1  \\
2 & 2 & 2 & 2 & 2 & 2 & 2 \\ 
2 & 2 & 2 & 2 & 2 & 2 & 2 \\
2 & 2 & 2 & 2 & 2 & 2 & 2 \\ 
\end{bmatrix}
$$

The contribution to the sum of squares from the first row is:

$$
(5-(x+1))^2 + (3-(x+1))^2 + (2-(x+1))^2 + (1-(x+1))^2 + (4-(x+1))^2 + (3-(x+1))^2 \\
= (4-x)^2 + (2-x)^2 + (1-x)^2 + (-x)^2 + (3-x)^2 + (2-x)^2
$$

and we want a value of x that minimizes the sum, so we take the derivative and set that equal to 0, as:
$$ -2((4-x)+ (2-x)+ (1-x)+ (-x) + (3-x) + (2-x)) = 0 $$
from which we get x = 2. 

Now update the U and V martix with the enrty that $u_{11}=2$.

$$
\begin{bmatrix}
2 & 1 \\
1 & 1 \\
1 & 1 \\
1 & 1  
\end{bmatrix}
\times 
\begin{bmatrix}
1 & 1 & 1 & 1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & 1 & 1 & 1 
\end{bmatrix}
=
\begin{bmatrix}
3 & 3 & 3 & 3 & 3 & 3 & 3 \\
2 & 2 & 2 & 2 & 2 & 2 & 2 \\ 
2 & 2 & 2 & 2 & 2 & 2 & 2 \\
2 & 2 & 2 & 2 & 2 & 2 & 2 \\
\end{bmatrix}
$$

**Step 3 : Alter $v_{11}$ to reduce the RMSE as much as possible and update $v_{11}$**

**Step 4 : Iterate the steps above again and again until the RMSE.**

[CHECK UV PART IF NEED TO PARAPHRASE]

Now that we've discussed the math behind this, let's move on to some coding!

# Coding Example (R)

To apply the concepts we've learned so far, let us implement these concepts in R. R has a built-in library *recommenderlab*, which we will go to later. Before going that, let's first implement a basic cosine similarity solution manually in order to illustrate the point.
::: {.solution}
```{r packages, message=FALSE, warning=FALSE}
#library(R6030)     # functions for DS 6030
library(tidyverse) # functions for data manipulation   
library(recommenderlab) # function for remmondation systems
```

We will continue to use the initial movie rating example. Let's figure out which movie you should watch out of the three new movies.
```{r}
movie_ratings <- data.frame(
  WM1 = c(5, NA, 3, 4), 
  WM2 = c(NA, 4, 1, 2),
  WM3 = c(3, NA, NA, 3),
  WM4 = c(2, 5, 4, 5),
  NM1 = c(1, NA, 5, NA),
  NM2 = c(4, 2, NA, NA),
  NM3 = c(3, 5, 3, NA)
)
rownames(movie_ratings) <- c('Hyun', 'Eric', 'Chunru', 'You')
movie_ratings
```

We will need a function that computes cosine similarity as it was discussed earlier in this tutorial.
```{r}
# The two vectors must have the same length
cosine_similarity <- function(vec_1, vec_2) {
  vec_len <- length(vec_1)
  
  # NA values are replaced with 0
  vec_1[is.na(vec_1)] <- 0
  vec_2[is.na(vec_2)] <- 0
  
  # Computing the denominator
  vec_1_denom <- sqrt(sum(vec_1^2))
  vec_2_denom <- sqrt(sum(vec_2^2))
  denominator <- vec_1_denom * vec_2_denom
  
  # Computing the numerator
  tib = tibble(vec_1 = vec_1, vec_2 = vec_2)
  tib <- tib %>% mutate(products = vec_1 * vec_2)
  numerator <- sum(tib$products)
  
  # Return the cosine similarity
  return (numerator / denominator)
}
```

Let's check how similar your taste in movies are to the 3 friends who responded. Remember, the higher cosine similarity value means more similarity.
```{r}
# Extract each person's ratings as vectors
you <- as.numeric(as.vector(movie_ratings['You',]))
hyun <- as.numeric(as.vector(movie_ratings['Hyun',]))
eric <- as.numeric(as.vector(movie_ratings['Eric',]))
chunru <- as.numeric(as.vector(movie_ratings['Chunru',]))


# Compute distance using cosine similarity
similarities <- data.frame(
  cosine_similarity = c(cosine_similarity(you, hyun), cosine_similarity(you, eric), cosine_similarity(you, chunru))
)
rownames(similarities) <- c('Hyun', 'Eric', 'Chunru')
similarities
```
Based on these results, we can see that your taste in movies is most similar to Hyun's. We will use these similarity scores as weights for predicting your movie ratings for the three new movies.

```{r}
# Function for computing the weighted average
movie_rating_weighted_average <- function(movie, friends) {
  denominator <- 0
  numerator <- 0
  for (friend in friends) {
    friend_similarity <- similarities[friend,][1]
    friend_rating <- movie_ratings[friend, movie][1]
    
    # Weighted average will take into account users who actually rated the movie
    if (is.na(friend_rating)) next
    
    denominator <- denominator + friend_similarity
    numerator <- numerator + (friend_similarity * friend_rating)
  }
  
  return (numerator / denominator)
}
```
```{r}
friend_names <- c('Hyun', 'Eric', 'Chunru')
new_movies <- c('NM1', 'NM2', 'NM3')
new_movie_predicted_ratings <- tibble()
for (n in new_movies) {
  predicted_rating <- movie_rating_weighted_average(n, friend_names)
  prediction_tibble <- tibble(movie = n, predicted_rating = predicted_rating)
  new_movie_predicted_ratings <- bind_rows(new_movie_predicted_ratings, prediction_tibble)
}
new_movie_predicted_ratings
```
Based on these predictions, it looks like you will probably like NM3 the most out of all the options.

Now that we were able to get a feel of how collaborative filtering works through cosine similarity, we will now discuss how to make recommendations using the *recommenderlab* library.

We will start by converting our dataframe to a *realRatingMatrix* object:
```{r}
# convert the movie ratings data frame to a matrix
rmat <- as.matrix(movie_ratings)

# convert matrix to a recommenderlab realRatingMatrix
rmat <- as(rmat, "realRatingMatrix")
```

We can then proceed to creating our *Recommender* options. The library contains the options we discussed earlier in this tutorial. 

The type *UBCF* stands for *User-Based Collaborative Filtering* which we can use to apply cosine similarity and normalization. The implementation of *recommenderlabs* also makes use of a k-nearest neighbors algorithm when building this type of recommender.

The type *SVDF* stands for *Funk Singular Value Decomposition* which implements the UV decomposition technique.

We will create three versions:

1. Recommender using Cosine Similarity
2. Recommender using Cosine Similarity with Normalized values
3. Recommender using UV decomposition

```{r}
# Non-normalized cosine
reco <- Recommender(rmat, "UBCF", 
      param=list(normalize = NULL, method="Cosine"))

# Normalized centered cosine
reco_centered <- Recommender(rmat, "UBCF", 
      param=list(normalize = "center", method="Cosine"))

# UV decomposition
# The parameter k is the missing dimension for the decomposed matrices. 
# For this library, it cannot be greater than the number of users or the number of items
reco_uv <- Recommender(rmat, "SVDF", 
      param=list(k = 4))
```

Now we can check the results:
```{r}
predictions <- predict(reco, rmat, type="ratings")
print('Non-normalized Cosine Similarity')
predictions@data

predictions_centered <- predict(reco_centered, rmat, type="ratings")
print('Normalized Cosine Similarity')
predictions_centered@data

predictions_uv <- predict(reco_uv, rmat, type="ratings")
print('UV Decomposition')
predictions_uv@data
```
As we can see from the results, NM3 has the highest predicted rating for 2 out of the 3 models. This just shows how recommender systems can be built using different distance measures and algorithms and may produce varying results.

The *recommenderlab* library also provides ways to measure models against each other. To show this, we will need a bigger dataset. We will use a larger dataset of movie ratings from Netflix.

```{r}
netflix <- read.csv('unscaled_data.csv')
head(netflix)
```

We will then follow similar steps as earlier, by converting the dataframe into a matrix.
```{r}
# For this example, we will use a smaller set of observations and remove the customer id column
netflix_small <- netflix[1:100, 2:51]

# Filter to users who have made atleast 10 movie ratings
netflix_small <- netflix_small[rowSums(is.na(netflix_small))<40,]

# convert the netflix data frame to a matrix
netflix_rmat <- as.matrix(netflix_small)

# convert matrix to a recommenderlab realRatingMatrix
netflix_rmat <- as(netflix_rmat, "realRatingMatrix")
```

We can then split the data using the *evaluationScheme* function. We can also set a *goodRating* value. Since the ratings are on a scale of 1-5, we will use 3 for this example.
```{r}
# split the data into the training and the test set:
split_data <- evaluationScheme(
  netflix_rmat, 
  method="split", 
  train=0.8, 
  k=1, 
  given=10, 
  goodRating=3
)
```

We can then build our models using the training data:
```{r}
# Non-normalized cosine
netflix_reco <- Recommender(getData(split_data, "train"), "UBCF", 
      param=list(normalize = NULL, method="Cosine"))

# Normalized centered cosine
netflix_reco_centered <- Recommender(getData(split_data, "train"), "UBCF", 
      param=list(normalize = "center", method="Cosine"))

# UV decomposition
netflix_reco_uv <- Recommender(getData(split_data, "train"), "SVDF", 
      param=list(k = 4))
```

The *calcPredictioAccuracy* function calculates the error metrics for the models.
```{r}
netflix_predictions <- predict(netflix_reco, getData(split_data, "known"), type="ratings")
netflix_predictions_centered <- predict(netflix_reco_centered, getData(split_data, "known"), type="ratings")
netflix_predictions_uv <- predict(netflix_reco_uv, getData(split_data, "known"), type="ratings")

error_results <- rbind(
  cosine = calcPredictionAccuracy(netflix_predictions, getData(split_data, "unknown")),
  cosine_normalized = calcPredictionAccuracy(netflix_predictions_centered, getData(split_data, "unknown")),
  uv = calcPredictionAccuracy(netflix_predictions_uv, getData(split_data, "unknown"))
)
error_results
```

From these results, we can see that the Cosine Normalized model produced the lowest RMSE and MSE values for the Netflix data.

:::

# Coding Example (Python)

# References

Ullman, J., Leskovec, J., Rajaraman, A., (2012, July 4). Mining Massive Datasets. Cambridge University Press. Retrieved December 7, 2022, from http://infolab.stanford.edu/~ullman/mmds/book.pdf 

https://towardsdatascience.com/recommendation-systems-using-uv-decomposition-a1d4116be4a1

https://rpubs.com/jt_rpubs/285729

https://search.r-project.org/CRAN/refmans/recommenderlab/html/funkSVD.html

https://www.rdocumentation.org/packages/recommenderlab/versions/1.0.2/topics/evaluationScheme


https://github.com/cran/recommenderlab

https://cran.r-project.org/web/packages/recommenderlab/recommenderlab.pdf


https://www.cs.cmu.edu/~mgormley/courses/10601-s17/slides/lecture25-mf.pdf


